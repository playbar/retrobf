// GLSL shader autogenerated by cg2glsl.py.
#if defined(VERTEX)

#if __VERSION__ >= 130
#define COMPAT_VARYING out
#define COMPAT_ATTRIBUTE in
#define COMPAT_TEXTURE texture
#else
#define COMPAT_VARYING varying
#define COMPAT_ATTRIBUTE attribute
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
vec4 _oPosition1;
vec4 _r0007;
COMPAT_ATTRIBUTE vec4 VertexCoord;
COMPAT_ATTRIBUTE vec4 COLOR;
COMPAT_ATTRIBUTE vec4 TexCoord;
COMPAT_VARYING vec4 COL0;
COMPAT_VARYING vec4 TEX0;
 
uniform mat4 MVPMatrix;
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec4 _oColor;
    vec2 _otexCoord;
    _r0007 = VertexCoord.x*MVPMatrix[0];
    _r0007 = _r0007 + VertexCoord.y*MVPMatrix[1];
    _r0007 = _r0007 + VertexCoord.z*MVPMatrix[2];
    _r0007 = _r0007 + VertexCoord.w*MVPMatrix[3];
    _oPosition1 = _r0007;
    _oColor = COLOR;
    _otexCoord = TexCoord.xy;
    gl_Position = _r0007;
    COL0 = COLOR;
    TEX0.xy = TexCoord.xy;
} 
#elif defined(FRAGMENT)

#if __VERSION__ >= 130
#define COMPAT_VARYING in
#define COMPAT_TEXTURE texture
out vec4 FragColor;
#else
#define COMPAT_VARYING varying
#define FragColor gl_FragColor
#define COMPAT_TEXTURE texture2D
#endif

#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#define COMPAT_PRECISION mediump
#else
#define COMPAT_PRECISION
#endif
COMPAT_VARYING     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
vec4 _ret_0;
float _TMP11;
float _TMP10;
float _TMP27;
float _TMP9;
float _TMP8;
float _TMP6;
float _TMP5;
vec3 _TMP15;
float _TMP26;
float _TMP25;
float _TMP24;
float _TMP13;
float _TMP23;
vec2 _TMP12;
float _TMP22;
float _TMP21;
vec2 _TMP20;
float _TMP19;
float _TMP18;
float _TMP4;
input_dummy _IN1;
float _a0039;
vec2 _n0041;
vec2 _x0041;
vec2 _f0041;
vec4 _m0041;
int _j10041;
int _i10041;
vec2 _g10041;
vec2 _o10041;
float _d10041;
vec3 _col10041;
float _h10041;
vec2 _TMP46;
vec2 _p0047;
vec2 _x0059;
vec2 _x0061;
vec2 _a0067;
vec2 _a0069;
float _TMP70;
float _x0075;
vec3 _x0077;
float _x0085;
float _TMP88;
float _TMP94;
vec3 _TMP98;
float _TMP106;
float _a0111;
float _x0115;
float _TMP116;
float _a0123;
float _x0127;
float _TMP128;
COMPAT_VARYING vec4 TEX0;
 
uniform int FrameDirection;
uniform int FrameCount;
uniform COMPAT_PRECISION vec2 OutputSize;
uniform COMPAT_PRECISION vec2 TextureSize;
uniform COMPAT_PRECISION vec2 InputSize;
void main()
{
    vec2 _p1;
    float _k;
    vec3 _col;
    _p1 = (2.00000000E+03*(TEX0.xy*(TextureSize.xy/InputSize.xy)))/TextureSize.yy;
    _a0039 = 1.57077499E-02*float(FrameCount);
    _TMP4 = cos(_a0039);
    _k = 5.00000000E-01 - 5.00000000E-01*_TMP4;
    _x0041 = 6.00000000E+00*_p1;
    _n0041 = floor(_x0041);
    _f0041 = fract(_x0041);
    _m0041 = vec4( 8.00000000E+00, 0.00000000E+00, 0.00000000E+00, 0.00000000E+00);
    _j10041 = -1;
    for (; _j10041 <= 1; _j10041 = _j10041 + 1) { 
        _i10041 = -1;
        for (; _i10041 <= 1; _i10041 = _i10041 + 1) { 
            _g10041 = vec2(float(_i10041), float(_j10041));
            _p0047 = _n0041 + _g10041;
            _TMP18 = dot(_p0047, vec2( 1.27099998E+02, 3.11700012E+02));
            _TMP19 = dot(_p0047, vec2( 2.69500000E+02, 1.83300003E+02));
            _p0047 = vec2(_TMP18, _TMP19);
            _TMP21 = sin(_p0047.x);
            _TMP22 = sin(_p0047.y);
            _TMP20 = vec2(_TMP21, _TMP22);
            _x0059 = _TMP20*4.37585469E+04;
            _TMP46 = fract(_x0059);
            _x0061 = 2.99999993E-02*float(FrameCount) + 6.28310013E+00*_TMP46;
            _TMP21 = sin(_x0061.x);
            _TMP22 = sin(_x0061.y);
            _TMP12 = vec2(_TMP21, _TMP22);
            _o10041 = 5.00000000E-01 + 5.00000000E-01*_TMP12;
            _a0067 = (_g10041 - _f0041) + _o10041;
            _d10041 = length(_a0067);
            _a0069 = _n0041 + _g10041;
            _TMP13 = dot(_a0069, vec2( 7.00000000E+00, 1.13000000E+02));
            _TMP23 = sin(_TMP13);
            _x0075 = _TMP23*4.37585469E+04;
            _TMP70 = fract(_x0075);
            _x0077 = (_TMP70*2.50000000E+00 + 3.50000000E+00) + vec3( 2.00000000E+00, 3.00000000E+00, 0.00000000E+00);
            _TMP24 = sin(_x0077.x);
            _TMP25 = sin(_x0077.y);
            _TMP26 = sin(_x0077.z);
            _TMP15 = vec3(_TMP24, _TMP25, _TMP26);
            _col10041 = 5.00000000E-01 + 5.00000000E-01*_TMP15;
            _x0085 = 5.00000000E-01 + (5.00000000E-01*(_m0041.x - _d10041))/_k;
            _TMP27 = min(1.00000000E+00, _x0085);
            _TMP88 = max(0.00000000E+00, _TMP27);
            _h10041 = _TMP88*_TMP88*(3.00000000E+00 - 2.00000000E+00*_TMP88);
            _TMP94 = _m0041.x + _h10041*(_d10041 - _m0041.x);
            _m0041.x = _TMP94 - (_h10041*(1.00000000E+00 - _h10041)*_k)/(1.00000000E+00 + 3.00000000E+00*_k);
            _TMP98 = _m0041.yzw + _h10041*(_col10041 - _m0041.yzw);
            _m0041.yzw = _TMP98 - (_h10041*(1.00000000E+00 - _h10041)*_k)/(1.00000000E+00 + 3.00000000E+00*_k);
        } 
    } 
    _TMP5 = float((3.30000013E-01 >= _p1.y));
    _col = _m0041.yzw*(1.00000000E+00 - 8.00000012E-01*_m0041.x*_TMP5);
    _TMP6 = float((6.60000026E-01 >= _p1.y));
    _TMP106 = _m0041.x + _TMP6*(1.00000000E+00 - _m0041.x);
    _col = _col*_TMP106;
    _a0111 = _p1.y - 3.30000013E-01;
    _TMP8 = abs(_a0111);
    _x0115 = (_TMP8 - 4.99999989E-03)/2.00000033E-03;
    _TMP27 = min(1.00000000E+00, _x0115);
    _TMP116 = max(0.00000000E+00, _TMP27);
    _TMP9 = _TMP116*_TMP116*(3.00000000E+00 - 2.00000000E+00*_TMP116);
    _col = _col*_TMP9;
    _a0123 = _p1.y - 6.60000026E-01;
    _TMP10 = abs(_a0123);
    _x0127 = (_TMP10 - 4.99999989E-03)/2.00000033E-03;
    _TMP27 = min(1.00000000E+00, _x0127);
    _TMP128 = max(0.00000000E+00, _TMP27);
    _TMP11 = _TMP128*_TMP128*(3.00000000E+00 - 2.00000000E+00*_TMP128);
    _col = _col*_TMP11;
    _ret_0 = vec4(_col.x, _col.y, _col.z, 1.00000000E+00);
    FragColor = _ret_0;
    return;
} 
#endif
